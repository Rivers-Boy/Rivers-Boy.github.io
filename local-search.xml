<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spark源码解析（二）：Spark闭包检查</title>
    <link href="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpark%E9%97%AD%E5%8C%85%E6%A3%80%E6%9F%A5/"/>
    <url>/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpark%E9%97%AD%E5%8C%85%E6%A3%80%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="一、理解-Scala-闭包：Closures"><a href="#一、理解-Scala-闭包：Closures" class="headerlink" title="一、理解 Scala 闭包：Closures"></a>一、理解 Scala 闭包：Closures</h3><h4 id="1-1-闭包的定义"><a href="#1-1-闭包的定义" class="headerlink" title="1.1 闭包的定义"></a>1.1 闭包的定义</h4><p><span style="background:#dad5e9;"><a href>闭包</a>就是一个函数和与其相关的引用环境组合的一个整体(实体)。</span>进一步说，闭包是绑定了自由变量的函数实例。</p><p>通常来讲，闭包的实现机制是定义一个特殊的数据结构，保存了函数地址指针与闭包创建时的函数的词法环境以及绑定自由变量。</p><p>对于闭包最好的解释，莫过于《流程的Python》里给出的“它是延伸了作用域的函数，其中包括函数定义体引用，以及不在定义体定义的非全局变量。核心在于闭包能够访问定义体之外定义的非全局变量。”</p><p>在Scala中，函数引入传入的参数是再正常不过的事情了，比如 <code>(x: Int) =&gt; x &gt; 0</code>中，唯一在函数体<code>x &gt; 0</code>中用到的变量是x，即这个函数的唯一参数。</p><p>除此之外，Scala还支持引用其他地方定义的变量： <code>(x: Int) =&gt; x + more</code>，这个函数将<code>more</code>也作为入参，不过这个参数是哪里来的？从这个函数的角度来看，more是一个 <font color="red">自由变量</font> ，因为函数字面量本身并没有给more赋予任何含义。相反，<font color="green">x是一个绑定变量，因为它在该函数的上下文里有明确的定义：它被定义为该函数的唯一参数。</font>如果单独使用这个函数，而没有在任何处于作用域内的地方定more，编译器将报错：</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpark%E9%97%AD%E5%8C%85%E6%A3%80%E6%9F%A5/image-20230224152448542-7223495.png" alt="image-20230224152448542"></p><p>另一方面，只要能找到名为more的变量，同样的函数就能正常工作：</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpark%E9%97%AD%E5%8C%85%E6%A3%80%E6%9F%A5/image-20230224153042153-7223846.png" alt="image-20230224153042153"></p><p>运行时从任何带有自由变量的函数字面量，比如<code>(x: Int) =&gt; x + more</code>创建的函数，按照定义，要求捕获到它的自由变量more的绑定。相应的函数值结果（<strong>包含指向被捕获的more变量的引用</strong>）就被称为闭包，<strong>该名称源于“捕获”其自由变量从而“闭合”该函数字面量的动作</strong>。</p><h4 id="1-2-修改自由变量"><a href="#1-2-修改自由变量" class="headerlink" title="1.2 修改自由变量"></a>1.2 修改自由变量</h4><p>上面的例子可能会使我们出现一个疑问：如果more在闭包创建以后被改变会发生什么？</p><p>在scala中，答案是闭包可以看到这个改变。</p><p>我们继续上面的代码，例子如下：</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpark%E9%97%AD%E5%8C%85%E6%A3%80%E6%9F%A5/image-20230224160121423-7225683.png" alt="image-20230224160121423"></p><p><span style="background:#d4e9d5;">Scala的闭包捕获的是变量本身，而不是变量引用的值。</span>正如前面示例所展示的，为<code>(x: Int) =&gt; x + more</code>创建的闭包能够看到闭包外对more的修改。</p><p>反之也是成立的：闭包对于自由变量的修改，闭包外也是可以看到的。</p><h4 id="1-3-自由变量多副本"><a href="#1-3-自由变量多副本" class="headerlink" title="1.3 自由变量多副本"></a>1.3 自由变量多副本</h4><p>那么，如果一个闭包访问了某个随着程序运行会产生多个副本的变量会如何呢？</p><p>例如，如果一个闭包使用了某个函数的局部变量，而这个函数又被调用了多次，会怎么样？闭包每次访问到的是这个变量的哪一个实例呢？</p><p>我们通过代码来进行验证：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 第一次声明 more 变量</span><br>scala&gt; <span class="hljs-keyword">var</span> more = <span class="hljs-number">10</span><br>more: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 创建闭包函数</span><br>scala&gt; <span class="hljs-keyword">val</span> addMore10 = (x: <span class="hljs-type">Int</span>) =&gt; &#123;x + more&#125;<br>addMore10: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = $<span class="hljs-type">Lambda</span>$<span class="hljs-number">1223</span>/<span class="hljs-number">0x000000080079f840</span>@<span class="hljs-number">36810</span>c06<br><br><span class="hljs-comment">// 调用闭包函数</span><br>scala&gt; addMore10(<span class="hljs-number">9</span>)<br>res13: <span class="hljs-type">Int</span> = <span class="hljs-number">19</span><br><br><span class="hljs-comment">// 重新声明 more 变量</span><br>scala&gt; <span class="hljs-keyword">var</span> more = <span class="hljs-number">100</span><br>more: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 创建新的闭包函数</span><br>scala&gt; <span class="hljs-keyword">val</span> addMore100 = (x: <span class="hljs-type">Int</span>) =&gt; &#123;x + more&#125;<br>addMore100: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> =  $<span class="hljs-type">Lambda</span>$<span class="hljs-number">1237</span>/<span class="hljs-number">0x00000008007b1840</span><span class="hljs-meta">@ac</span>94285<br><br><span class="hljs-comment">// 引用的是重新声明 more 变量</span><br>scala&gt; addMore100(<span class="hljs-number">9</span>)<br>res14: <span class="hljs-type">Int</span> = <span class="hljs-number">109</span><br><br><span class="hljs-comment">// 引用的还是第一次声明的 more 变量</span><br>scala&gt; addMore10(<span class="hljs-number">9</span>)<br>res15: <span class="hljs-type">Int</span> = <span class="hljs-number">19</span><br><br><span class="hljs-comment">// 对于全局而言 more 还是 100</span><br>scala&gt; more<br>res16: <span class="hljs-type">Int</span> = <span class="hljs-number">100</span><br><br></code></pre></td></tr></table></figure><p>从上面的示例可以看出重新声明 <code>more</code> 后，全局的 <code>more</code> 的值是 100，但是对于闭包函数 <code>addMore10</code> 还是引用的是值为 10 的 <code>more</code>，这是由虚拟机来实现的，虚拟机会保证 <code>more</code> 变量在重新声明后，原来的被捕获的变量副本继续在堆上保持存活。</p><h4 id="1-4-闭包的实现"><a href="#1-4-闭包的实现" class="headerlink" title="1.4 闭包的实现"></a>1.4 闭包的实现</h4><p>具体的实现细节较为复杂（其实是自己也不是很懂，看字节码有点头疼），这里简单介绍一下</p><p>对于普通方法，局部变量在调用的时候是压入栈中的，计算完成之后就会 pop 出，所以在函数的调用完成后就不能再访问这个变量</p><p>而Scala中的闭包：实际上是在Heap上创建了一个闭包函数的相关对象，在传入参数后进行初始化，并将最终得到的实例对象的引用压入到栈中</p><p>总结：<span style="background:#fbd4d0;">Scala 实现闭包的方法是在 heap 中保存了使用不同参数初始化而产生的不同对象，对象中保存了变量的状态，然后调用具体对象的 apply 方法而最后产生不同的结果。</span></p><p>编译后会生成一个Closures$$<font color="red">anonfun</font>$addMore$1的类文件</p><h3 id="二、Spark中对于闭包的处理"><a href="#二、Spark中对于闭包的处理" class="headerlink" title="二、Spark中对于闭包的处理"></a>二、Spark中对于闭包的处理</h3><p>Spark中闭包检测的目的：</p><p>为了防止spark程序中将闭包发送到Executor节点时发生序列化失败，因为闭包函数有可能引用了未序列化的外部变量</p><h4 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h4><p>在进入转换算子(例如map)的时候，会先调用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> cleanF = sc.clean(f)<br></code></pre></td></tr></table></figure><p>进入clean函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span>[spark] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean</span></span>[<span class="hljs-type">F</span> &lt;: <span class="hljs-type">AnyRef</span>](f: <span class="hljs-type">F</span>, checkSerializable: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>): <span class="hljs-type">F</span> = &#123;<br>  <span class="hljs-type">ClosureCleaner</span>.clean(f, checkSerializable)<br>  f<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="background:#dad5e9;">闭包检测的核心类：ClosureCleaner</span></p><p>最终调用的clean方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean</span></span>(<br>    closure: <span class="hljs-type">AnyRef</span>,  <span class="hljs-comment">//这个就是我们检测的函数</span><br>    checkSerializable: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>,<span class="hljs-comment">//在闭包clean后对闭包能否序列化进行检测</span><br>    cleanTransitively: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>): <span class="hljs-type">Unit</span> = &#123;<span class="hljs-comment">//是否传递性的清理闭包</span><br>  clean(closure, checkSerializable, cleanTransitively, <span class="hljs-type">Map</span>.empty)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="核心方法：clean"><a href="#核心方法：clean" class="headerlink" title="核心方法：clean()"></a>核心方法：clean()</h4><p>首先通过<span style="background:#d4e9d5;">isClosure</span>方法判断是否为闭包类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">if</span> (!isClosure(func.getClass) &amp;&amp; maybeIndylambdaProxy.isEmpty) &#123;<br>  logDebug(<span class="hljs-string">s&quot;Expected a closure; got <span class="hljs-subst">$&#123;func.getClass.getName&#125;</span>&quot;</span>)<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><span style="background:#d4e9d5;">isClosure</span>这个函数怎么判断是否为闭包类呢？</p><p>发现和我们上文scala的class文件对应起来了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isClosure</span></span>(cls: <span class="hljs-type">Class</span>[_]): <span class="hljs-type">Boolean</span> = &#123;<br>  cls.getName.contains(<span class="hljs-string">&quot;$anonfun$&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后通过<span style="background:#d4e9d5;">getOuterClassesAndObejct()</span>函数获取func中所有对于外部闭包对象的引用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// A list of classes that represents closures enclosed in the given one</span><br><span class="hljs-keyword">val</span> innerClasses = getInnerClosureClasses(func)<br><br><span class="hljs-comment">// A list of enclosing objects and their respective classes, from innermost to outermost</span><br><span class="hljs-comment">// An outer object at a given index is of type outer class at the same index</span><br><span class="hljs-keyword">val</span> (outerClasses, outerObjects) = getOuterClassesAndObjects(func)<br></code></pre></td></tr></table></figure><p>遍历class文件中的所有field，找到$outer的就是外部的闭包引用，同时，如果外部闭包引用也是闭包类，那么同样获取其外部，直到最外层的非闭包类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getOuterClassesAndObjects</span></span>(obj: <span class="hljs-type">AnyRef</span>): (<span class="hljs-type">List</span>[<span class="hljs-type">Class</span>[_]], <span class="hljs-type">List</span>[<span class="hljs-type">AnyRef</span>]) = &#123;<br>  <span class="hljs-keyword">for</span> (f &lt;- obj.getClass.getDeclaredFields <span class="hljs-keyword">if</span> f.getName == <span class="hljs-string">&quot;$outer&quot;</span>) &#123;<br>    f.setAccessible(<span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">val</span> outer = f.get(obj)<br>    <span class="hljs-comment">// The outer pointer may be null if we have cleaned this closure before</span><br>    <span class="hljs-keyword">if</span> (outer != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (isClosure(f.getType)) &#123;<br>        <span class="hljs-keyword">val</span> recurRet = getOuterClassesAndObjects(outer)<br>        <span class="hljs-keyword">return</span> (f.getType :: recurRet._1, outer :: recurRet._2)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (f.getType :: <span class="hljs-type">Nil</span>, outer :: <span class="hljs-type">Nil</span>) <span class="hljs-comment">// Stop at the first $outer that is not a closure</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  (<span class="hljs-type">Nil</span>, <span class="hljs-type">Nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而后，禁止func中出现return返回值，在这里扫描，如果出现return直接报错。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// Fail fast if we detect return statements in closures</span><br>getClassReader(func.getClass).accept(<span class="hljs-keyword">new</span> <span class="hljs-type">ReturnStatementFinder</span>(), <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReturnStatementFinder</span>(<span class="hljs-params">targetMethodName: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">None</span></span>)</span><br>  <span class="hljs-keyword">extends</span> <span class="hljs-type">ClassVisitor</span>(<span class="hljs-type">ASM9</span>) &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visitMethod</span></span>(access: <span class="hljs-type">Int</span>, name: <span class="hljs-type">String</span>, desc: <span class="hljs-type">String</span>,<br>      sig: <span class="hljs-type">String</span>, exceptions: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">MethodVisitor</span> = &#123;<br><br>    <span class="hljs-comment">// $anonfun$ covers indylambda closures</span><br>    <span class="hljs-keyword">if</span> (name.contains(<span class="hljs-string">&quot;apply&quot;</span>) || name.contains(<span class="hljs-string">&quot;$anonfun$&quot;</span>)) &#123;<br>      <span class="hljs-comment">// A method with suffix &quot;$adapted&quot; will be generated in cases like</span><br>      <span class="hljs-comment">// &#123; _:Int =&gt; return; Seq()&#125; but not &#123; _:Int =&gt; return; true&#125;</span><br>      <span class="hljs-comment">// closure passed is $anonfun$t$1$adapted while actual code resides in $anonfun$s$1</span><br>      <span class="hljs-comment">// visitor will see only $anonfun$s$1$adapted, so we remove the suffix, see</span><br>      <span class="hljs-comment">// https://github.com/scala/scala-dev/issues/109</span><br>      <span class="hljs-keyword">val</span> isTargetMethod = targetMethodName.isEmpty ||<br>        name == targetMethodName.get || name == targetMethodName.get.stripSuffix(<span class="hljs-string">&quot;$adapted&quot;</span>)<br><br>      <span class="hljs-keyword">new</span> <span class="hljs-type">MethodVisitor</span>(<span class="hljs-type">ASM9</span>) &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visitTypeInsn</span></span>(op: <span class="hljs-type">Int</span>, tp: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = &#123;<br>          <span class="hljs-keyword">if</span> (op == <span class="hljs-type">NEW</span> &amp;&amp; tp.contains(<span class="hljs-string">&quot;scala/runtime/NonLocalReturnControl&quot;</span>) &amp;&amp; isTargetMethod) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ReturnStatementInClosureException</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">MethodVisitor</span>(<span class="hljs-type">ASM9</span>) &#123;&#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>todo：后面理解深了继续看，已经不是很能看得懂了</p>]]></content>
    
    
    <categories>
      
      <category>Spark源码系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spark源码解析（一）：RDD之Transfrom算子</title>
    <link href="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/"/>
    <url>/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、延迟计算"><a href="#一、延迟计算" class="headerlink" title="一、延迟计算"></a>一、延迟计算</h3><p>RDD 代表的是分布式数据形态，因此，RDD 到 RDD 之间的转换，本质上是数据形态上的转换（Transformations）</p><p>在 RDD 的编程模型中，一共有两种算子，Transformations 类算子和 Actions 类算子。开发者需要使用 Transformations 类算子，定义并描述数据形态的转换过程，然后调用 Actions 类算子，将计算结果收集起来、或是物化到磁盘。</p><p>在这样的编程模型下，Spark 在运行时的计算被划分为两个环节。</p><ol><li>基于不同数据形态之间的转换，构建计算流图（DAG，Directed Acyclic Graph）</li><li>通过 Actions 类算子，以回溯的方式去触发执行这个计算流图</li></ol><p>换句话说，开发者调用的各类 Transformations 算子，并不立即执行计算，当且仅当开发者调用 Actions 算子时，之前调用的转换算子才会付诸执行。在业内，这样的计算模式有个专门的术语，叫作“延迟计算”（Lazy Evaluation）。</p><h3 id="二、Spark算子分类"><a href="#二、Spark算子分类" class="headerlink" title="二、Spark算子分类"></a>二、Spark算子分类</h3><p>在 RDD 的开发框架下，哪些算子属于 Transformations 算子，哪些算子是 Actions 算子呢？</p><p>这里给出一张自己在极客看的课程中的图</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/4f277fdda5a4b34b3e2yyb6f570a08fa-20230224103633631-7206198.jpg" alt="img"></p><h3 id="三、Transform算子执行流程-源码"><a href="#三、Transform算子执行流程-源码" class="headerlink" title="三、Transform算子执行流程(源码)"></a>三、Transform算子执行流程(源码)</h3><p>Map转换算是 RDD 的经典转换操作之一了.就以它开头.Map的源码如下：</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224103912741-7206357.png" alt="image-20230224103912741"></p><h4 id="1-sc-clean-f"><a href="#1-sc-clean-f" class="headerlink" title="1. sc.clean(f)"></a>1. sc.clean(f)</h4><p>首先掉了一个sc.clean(f) , 我们进到clean函数里看下:</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224104117191-7206479.png" alt="image-20230224104117191"></p><p>注释中明确提到了这个函数的功能：clean 整理一个闭包，使其可以序列化并发送到任务.</p><p>这里的代码有些多，大概知道这个函数的功能是这样就ok了，闭包的问题会在另一篇文章里仔细介绍</p><h4 id="2-MapPartitionsRDD"><a href="#2-MapPartitionsRDD" class="headerlink" title="2. MapPartitionsRDD"></a>2. MapPartitionsRDD</h4><p>进入到函数后源码如下：</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224105719758-7207443.png" alt="image-20230224105719758"></p><p>这是一个MapPartitionsRDD。我们仔细看它的构成，从而来理解它是如何描述MapPartitionsRDD的.</p><h5 id="2-1-var-prev：RDD-T"><a href="#2-1-var-prev：RDD-T" class="headerlink" title="2.1 var prev：RDD[T]"></a>2.1 var <font color="red">prev</font>：RDD[T]</h5><p>这里的 <font color="red">prev</font> 就是父RDD，<font color="red">f </font> 则是Map中传入的处理函数，除了这两个就没有了，也就是说明 RDD中没有存储具体的数据本身</p><p>这再次印证了<font color="green"><strong>转换不会产生任何数据.它只是单纯了记录父RDD以及如何转换的过程就完了,不会在转换阶段产生任何数据集</strong></font></p><h5 id="2-2-preservesPartitioning"><a href="#2-2-preservesPartitioning" class="headerlink" title="2.2 preservesPartitioning"></a>2.2 preservesPartitioning</h5><p>preservesPartitioning 表示<font color="red">是否保持父RDD的分区信息. </font><br>如果为false(默认为false),则会对结果重新分区.也就是Map系默认都会分区<br>如果为true,保留分区. 则按照 firstParent 保留分区　　　</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224110557226-7207959.png" alt="image-20230224110557226"></p><p>可以看到根据 dependencies 找到其第一个父 RDD</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224110711910-7208033.png" alt="image-20230224110711910"></p><h5 id="2-3-compute-计算逻辑"><a href="#2-3-compute-计算逻辑" class="headerlink" title="2.3 compute 计算逻辑"></a>2.3 compute 计算逻辑</h5><h6 id="2-3-1-compute方法"><a href="#2-3-1-compute方法" class="headerlink" title="2.3.1 compute方法"></a>2.3.1 compute方法</h6><p><code>RDD</code> 抽象类要求其所有子类都必须实现 <code>compute</code> 方法，该方法接受的参数之一是一个<code>Partition</code> 对象，目的是计算该分区中的数据。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute</span></span>(split: <span class="hljs-type">Partition</span>, context: <span class="hljs-type">TaskContext</span>): <span class="hljs-type">Iterator</span>[<span class="hljs-type">U</span>] =<br>  f(context, split.index, firstParent[<span class="hljs-type">T</span>].iterator(split, context))<br></code></pre></td></tr></table></figure><p>可以看到，compute 方法调用当前 RDD 内的第一个父 RDD 的 <font color="red">iterator</font> 方法，该方的目的是拉取父 <code>RDD</code> 对应分区内的数据。</p><p><code>iterator</code> 方法会返回一个迭代器对象，<font color="red">迭代器内部存储的每个元素即父 RDD 对应分区内<strong>已经计算完毕的数据记录</strong></font>。得到的迭代器作为 <code>f</code> 方法的一个参数。<code>f</code> 在 <code>RDD</code> 类的 <code>map</code> 方法中指定，即实际的转换函数。</p><p><code>compute</code> 方法会将迭代器中的记录一一输入 <code>f</code> 方法，得到的新迭代器即为所求分区中的数据。</p><p>其他 <code>RDD</code> 子类的 <code>compute</code> 方法与之类似，在需要用到父 RDD 的分区数据时候，就会调用 <code>iterator</code> 方法，然后根据需求在得到的数据之上执行粗粒度的操作。<strong>换句话说，<code>compute</code> 函数负责的是父 <code>RDD</code> 分区数据到子 <code>RDD</code> 分区数据的变换逻辑。</strong></p><h6 id="2-3-2-iterator方法"><a href="#2-3-2-iterator方法" class="headerlink" title="2.3.2 iterator方法"></a>2.3.2 iterator方法</h6><p>此方法的实现在 RDD 这个抽象类中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Internal method to this RDD; will read from cache if applicable, or otherwise compute it.</span><br><span class="hljs-comment"> * This should &#x27;&#x27;not&#x27;&#x27; be called by users directly, but is available for implementers of custom</span><br><span class="hljs-comment"> * subclasses of RDD.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iterator</span></span>(split: <span class="hljs-type">Partition</span>, context: <span class="hljs-type">TaskContext</span>): <span class="hljs-type">Iterator</span>[<span class="hljs-type">T</span>] = &#123;<br>  <span class="hljs-keyword">if</span> (storageLevel != <span class="hljs-type">StorageLevel</span>.<span class="hljs-type">NONE</span>) &#123;<br>    getOrCompute(split, context)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    computeOrReadCheckpoint(split, context)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>interator首先检查 <font color="red">存储级别 storageLevel</font>：此处可参考<a href="https://doc.yonyoucloud.com/doc/spark-programming-guide-zh-cn/programming-guide/rdds/rdd-persistences.html">RDD持久化</a></p><p>如果存储级别不是NONE, 说明分区的数据说明分区的数据要么已经存储在文件系统当中，要么当前 RDD 曾经执行过 <code>cache</code>、 <code>persise</code> 等持久化操作，此时需要从存储空间读取分区数据，调用  <font color="green">getOrCompute</font>  方法</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224114953570-7210595.png" alt="image-20230224114953570"></p><p>getOrCompute  方法会根据  <font color="red">RDD 编号：id</font> 与 <font color="red">分区编号：partition.index</font> 计算得到当前分区在存储层对应的<font color="red">块编号：blockId</font>，通过存储层提供的数据读取接口提取出块的数据。</p><p>代码中的这几句注释给的非常到位，大致的判断顺序如下：</p><ul><li>块命中的情况：也就是数据之前已经成功存储到介质中，这其中可能是数据本身就在存储介质中（比如通过读取HDFS创建的RDD），也可能是 RDD 在经过持久化操作并且经历了一次计算过程，这个时候我们就能成功读取数据并将其返回</li><li>块未命中的情况：可能是数据已经丢失，或者 RDD 经过持久化操作，但是是当前分区数据是第一次被计算，因此会出现拉取得到数据为 <code>None</code> 的情况。这就意味着我们需要计算分区数据，继续调用 <code>RDD</code> 类 <code>computeOrReadCheckpoint</code> 方法来计算数据，并将计算得到的数据缓存到存储介质中，下次就无需再重复计算。</li></ul><p>如果当前RDD的存储级别为 <code>None</code>，说明为未经持久化的 <code>RDD</code>，需要重新计算 RDD 内的数据，这时候调用 <code>RDD</code> 类的 <code>computeOrReadCheckpoint</code> 方法，该方法也在持久化 RDD 的分区获取数据失败时被调用。</p><p><img src="/2023/02/24/Spark%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARDD%E4%B9%8BTransfrom%E7%AE%97%E5%AD%90/image-20230224142431572-7219874.png" alt="image-20230224142431572"></p><p><font color="red">computeOrReadCheckpoint</font> 方法会检查当前 RDD 是否已经被标记成检查点，如果未被标记成检查点，则执行自身的 <code>compute</code> 方法来计算分区数据，否则就直接拉取父 RDD 分区内的数据。</p><p>需要注意的是，对于标记成检查点的情况，当前 RDD 的父 RDD 不再是原先转换操作中提供数据的父 RDD，而是被 Apache Spark 替换成一个 <font color="red">CheckpointRDD</font> 对象，该对象中的数据存放在文件系统中，因此最终该对象会从文件系统中读取数据并返回给 <code>computeOrReadCheckpoint</code> 方法</p><p>参考文章：</p><p><a href="https://spark-internals.books.yourtion.com/markdown/6-CacheAndCheckpoint.html">Cache 和 Checkpoint</a></p>]]></content>
    
    
    <categories>
      
      <category>Spark源码系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能监控命令</title>
    <link href="/2023/01/18/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/01/18/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="一、top"><a href="#一、top" class="headerlink" title="一、top"></a>一、top</h3><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p><h3 id="二、dstat"><a href="#二、dstat" class="headerlink" title="二、dstat"></a>二、dstat</h3><h3 id="三、sar"><a href="#三、sar" class="headerlink" title="三、sar"></a>三、sar</h3><h3 id="四、iftop"><a href="#四、iftop" class="headerlink" title="四、iftop"></a>四、iftop</h3><h3 id="五、pidstat"><a href="#五、pidstat" class="headerlink" title="五、pidstat"></a>五、pidstat</h3><h3 id="六、profiling"><a href="#六、profiling" class="headerlink" title="六、profiling"></a>六、profiling</h3>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2023/01/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/01/17/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="一、文件和目录帮助命令"><a href="#一、文件和目录帮助命令" class="headerlink" title="一、文件和目录帮助命令"></a>一、文件和目录帮助命令</h3><table><thead><tr><th><strong>ls</strong></th><th>全拼 list，功能是列出目录的内容及其内容属性信息。</th></tr></thead><tbody><tr><td><strong>cd</strong></td><td>全拼 change directory，功能是从当前工作目录切换到指定的工作目录。</td></tr><tr><td><strong>cp</strong></td><td>全拼 copy，其功能为复制文件或目录。</td></tr><tr><td><strong>find</strong></td><td>查找的意思，用于查找目录及目录下的文件。<a href="https://www.runoob.com/linux/linux-comm-find.html">具体参数用法</a></td></tr><tr><td><strong>mkdir</strong></td><td>全拼 make directories，其功能是创建目录。</td></tr><tr><td><strong>mv</strong></td><td>全拼 move，其功能是移动或重命名文件。<a href="https://www.runoob.com/linux/linux-comm-mv.html">具体参数用法</a></td></tr><tr><td><strong>pwd</strong></td><td>全拼 print working directory，其功能是显示当前工作目录的绝对路径。</td></tr><tr><td><strong>rename</strong></td><td>用于重命名文件。(macos不支持此命令)</td></tr><tr><td><strong>rm</strong></td><td>全拼 remove，其功能是删除一个或多个文件或目录。 <a href="https://www.runoob.com/linux/linux-comm-rm.html">具体参数用法</a></td></tr><tr><td><strong>rmdir</strong></td><td>全拼 remove empty directories，功能是删除空目录。</td></tr><tr><td><strong>touch</strong></td><td>创建新的空文件，改变已有文件的时间戳属性。</td></tr><tr><td><strong>tree</strong></td><td>功能是以树形结构显示目录下的内容。(<strong>此命令可能需要自己安装下</strong>)</td></tr><tr><td><strong>lsattr</strong></td><td>查看文件扩展属性。</td></tr><tr><td><strong>file</strong></td><td>显示文件的类型。</td></tr><tr><td><strong>md5sum</strong></td><td>计算和校验文件的 MD5 值。</td></tr></tbody></table><h3 id="二、查看文件及内容处理命令"><a href="#二、查看文件及内容处理命令" class="headerlink" title="二、查看文件及内容处理命令"></a>二、查看文件及内容处理命令</h3><table><thead><tr><th>cat</th><th>全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</th></tr></thead><tbody><tr><td><strong>tac</strong></td><td>tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。<a href="https://www.runoob.com/linux/linux-comm-cat.html">具体参数用法</a></td></tr><tr><td><strong>more/less</strong></td><td>分页显示文件内容。</td></tr><tr><td><strong>head/tail</strong></td><td>显示文件内容的头部/尾部</td></tr><tr><td><strong>wc</strong></td><td>统计文件的行数、单词数或字节数。</td></tr><tr><td><strong>grep</strong></td><td>用于查找文件里符合条件的字符串。<a href="https://www.runoob.com/linux/linux-comm-grep.html">具体参数用法</a></td></tr></tbody></table><h3 id="三、文件压缩及解压缩"><a href="#三、文件压缩及解压缩" class="headerlink" title="三、文件压缩及解压缩"></a>三、文件压缩及解压缩</h3><table><thead><tr><th>tar</th><th>打包压缩</th></tr></thead><tbody><tr><td><strong>unzip</strong></td><td>解压文件。</td></tr><tr><td><strong>gzip</strong></td><td>gzip 压缩工具。</td></tr><tr><td><strong>zip</strong></td><td>压缩工具。</td></tr></tbody></table><h3 id="四、信息显示命令"><a href="#四、信息显示命令" class="headerlink" title="四、信息显示命令"></a>四、信息显示命令</h3><table><thead><tr><th>uname</th><th>显示操作系统相关信息的命令。</th></tr></thead><tbody><tr><td><strong>hostname</strong></td><td>显示或者设置当前系统的主机名。(<strong>需要权限</strong>)</td></tr><tr><td><strong>uptime</strong></td><td>显示系统运行时间及负载。</td></tr><tr><td><strong>stat</strong></td><td>显示文件或文件系统的状态。</td></tr><tr><td><strong>du</strong></td><td>disk usage，计算磁盘空间使用情况。<a href="https://www.runoob.com/linux/linux-comm-du.html">具体参数用法</a></td></tr><tr><td><strong>df</strong></td><td>disk free,显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</td></tr><tr><td><strong>top</strong></td><td>实时显示系统资源使用情况。<a href="https://www.runoob.com/linux/linux-comm-top.html">具体参数用法</a></td></tr><tr><td><strong>free</strong></td><td>查看系统内存。</td></tr></tbody></table><h3 id="五、网络操作命令"><a href="#五、网络操作命令" class="headerlink" title="五、网络操作命令"></a>五、网络操作命令</h3><table><thead><tr><th>ssh</th><th>使用 SSH 加密协议远程登录。</th></tr></thead><tbody><tr><td><strong>scp</strong></td><td>全拼 secure copy，用于不同主机之间复制文件。</td></tr><tr><td><strong>wget</strong></td><td>命令行下载文件。</td></tr><tr><td><strong>ping</strong></td><td>测试主机之间网络的连通性。</td></tr><tr><td><strong>Ifconfig</strong></td><td>查看、配置、启用或禁用网络接口的命令。 <a href="https://www.runoob.com/linux/linux-comm-ifconfig.html">具体细节用法</a></td></tr><tr><td><strong>netstat</strong></td><td>查看网络状态。<a href="https://www.runoob.com/linux/linux-comm-netstat.html">具体参数用法</a></td></tr><tr><td><strong>lsof</strong></td><td>全名 list open files，也就是列举系统中已经被打开的文件。<a href></a></td></tr><tr><td><strong>traceroute</strong></td><td>追踪数据传输路由状况。</td></tr><tr><td><strong>tcpdump</strong></td><td>命令行的抓包工具。</td></tr></tbody></table><h3 id="六、系统权限及用户授权"><a href="#六、系统权限及用户授权" class="headerlink" title="六、系统权限及用户授权"></a>六、系统权限及用户授权</h3><table><thead><tr><th>chmod</th><th>改变文件或目录权限。 <a href="https://www.runoob.com/linux/linux-comm-chmod.html">具体用法</a></th></tr></thead><tbody><tr><td>chown</td><td><strong>change owner</strong>,改变文件或目录的属主和属组。</td></tr><tr><td>chgrp</td><td>更改文件用户组。</td></tr><tr><td>umask</td><td>显示或设置权限掩码。</td></tr></tbody></table><h3 id="七、-内置命令及其他"><a href="#七、-内置命令及其他" class="headerlink" title="七、 内置命令及其他"></a>七、 内置命令及其他</h3><table><thead><tr><th>echo</th><th>打印变量，或直接输出指定的字符串</th></tr></thead><tbody><tr><td>printf</td><td>将结果格式化输出到标准输出。</td></tr><tr><td>rpm</td><td>管理 rpm 包的命令。</td></tr><tr><td>yum</td><td>自动化简单化地管理 rpm 包的命令。</td></tr><tr><td>watch</td><td>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</td></tr><tr><td>nc</td><td>功能强大的网络工具。</td></tr><tr><td>xargs</td><td>将标准输入转换成命令行参数。</td></tr><tr><td>exec</td><td>调用并执行指令的命令。</td></tr><tr><td>export</td><td>设置或者显示环境变量。</td></tr></tbody></table><h3 id="八、-系统管理与性能监视命令"><a href="#八、-系统管理与性能监视命令" class="headerlink" title="八、 系统管理与性能监视命令"></a>八、 系统管理与性能监视命令</h3><table><thead><tr><th>chkconfig</th><th>管理 Linux 系统开机启动项。</th></tr></thead><tbody><tr><td>vmstat</td><td>虚拟内存统计。</td></tr><tr><td>mpstat</td><td>显示各个可用 CPU 的状态统计。</td></tr><tr><td>iostat</td><td>统计系统 IO。</td></tr><tr><td>sar</td><td>全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。</td></tr><tr><td>ipcs</td><td>用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</td></tr><tr><td>ipcrm</td><td>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</td></tr><tr><td>strace</td><td>用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</td></tr><tr><td>ltrace</td><td>命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。</td></tr></tbody></table><h3 id="九、关机-重启-注销和查看系统信息的命令"><a href="#九、关机-重启-注销和查看系统信息的命令" class="headerlink" title="九、关机 / 重启 / 注销和查看系统信息的命令"></a>九、关机 / 重启 / 注销和查看系统信息的命令</h3><table><thead><tr><th>shutdown</th><th>关机。</th></tr></thead><tbody><tr><td>halt</td><td>关机。</td></tr><tr><td>poweroff</td><td>关闭电源。</td></tr><tr><td>logout</td><td>退出当前登录的 Shell。</td></tr><tr><td>exit</td><td>退出当前登录的 Shell。</td></tr><tr><td>Ctrl+d</td><td>退出当前登录的 Shell 的快捷键。</td></tr></tbody></table><h3 id="十、进程管理相关命令"><a href="#十、进程管理相关命令" class="headerlink" title="十、进程管理相关命令"></a>十、进程管理相关命令</h3><table><thead><tr><th>bg</th><th>将一个在后台暂停的命令，变成继续执行  （在后台执行）。</th></tr></thead><tbody><tr><td>fg</td><td>将后台中的命令调至前台继续运行。</td></tr><tr><td>jobs</td><td>查看当前有多少在后台运行的命令。</td></tr><tr><td>kill</td><td>终止进程。</td></tr><tr><td>killall</td><td>通过进程名终止进程。</td></tr><tr><td>pkill</td><td>通过进程名终止进程。</td></tr><tr><td>crontab</td><td>定时任务命令。</td></tr><tr><td>ps</td><td>显示进程的快照。</td></tr><tr><td>pstree</td><td>树形显示进程。</td></tr><tr><td>nice/renice</td><td>调整程序运行的优先级。</td></tr><tr><td>nohup</td><td>忽略挂起信号运行指定的命令。</td></tr><tr><td>pgrep</td><td>查找匹配条件的进程。</td></tr><tr><td>runlevel</td><td>查看系统当前运行级别。</td></tr><tr><td>init</td><td>切换运行级别。</td></tr><tr><td>service</td><td>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID控制及其代码实现</title>
    <link href="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、问题的引出"><a href="#一、问题的引出" class="headerlink" title="一、问题的引出"></a>一、问题的引出</h1><h3 id="1-应用的场景"><a href="#1-应用的场景" class="headerlink" title="1. 应用的场景"></a>1. 应用的场景</h3><p>生活中的一些小电器，无人机的飞行姿态和飞行速度控制等等，都应用到 PID——PID 控制在自动控制原理中是一套比较经典的算法。</p><p>我们常见到这类设备，只不过没有留心或者发现了没有深入探究以及主动搜索一下其中的原理而已</p><p>你一定用过恒温热水壶，你想让热水壶的水保持在一个恒定的温度，回到家拿起来就喝，不需要慢慢等水烧开再等到水冷却到适合咕咚咕咚喝的温度。</p><p>也许热水壶不需要那么高的精度，但是比如自动驾驶中控制汽车维持在某个设定的速度行驶，或将汽车保持在一个固定车道内行驶，又比如让飞机停在某个高度上，这些就需要非常精准</p><p>接下来，我们来一起了解下PID的发展与原理</p><h3 id="2-开环式控制"><a href="#2-开环式控制" class="headerlink" title="2. 开环式控制"></a>2. 开环式控制</h3><p>比如将飞机停在某个高度，<font color="green">我们应该怎么做呢？</font>此时大家在想，这不是so easy吗？</p><p>比如飞行高度问题，假设我们想要飞到50m处，只要我们设定它飞行速度为10m/s，并给出指令让它飞行5s，是不是就能很轻易的完成我们的目标呢？</p><p><img src="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20221017184401198-6003444.png" alt="image-20221017184401198"></p><p>上述的指令就是一个经典的<strong>开环控制</strong>，即输出并不会反过来影响输入。开环控制适合于简单的任务或者精确度要求不高的情形。</p><h3 id="3-闭环控制之启停式控制"><a href="#3-闭环控制之启停式控制" class="headerlink" title="3. 闭环控制之启停式控制"></a>3. 闭环控制之启停式控制</h3><p>开环控制在理想的状态下是完全没问题的，但是真实的世界就是这么不理想哈哈哈哈。比如飞机超重速度没有达到我们要求的？比如飞行的过程中突然刮了大风。但凡有一点的意外情况，按照我们的程序指令 ，这个飞机是不太可能停在50m高度的。</p><p>这时候自然而然地想到：如果高度不够，就再飞一截呗；超出去了，就下下呗。<strong>闭环控制</strong>不就来了吗</p><p><img src="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20221017184607895-6003570.png" alt="image-20221017184607895"></p><p>我们来想这样的场景，飞机上升到了50m，我们立马停，发现超了，往下飞，再停，循环往复</p><p>这就是启停式控制：这种情况下，相当于<strong>只有0和1两种状态</strong>。启停式控制最大的缺点就是缺乏稳定性，在期望值附近的波动会非常大。</p><p>这时候我们就会想，难道就不能更智能一点吗？比如可以在差得多的时候飞的快点，快到了就让它慢点；比如说能不能减少误差的影响呢等等</p><h1 id="二、PID控制算法"><a href="#二、PID控制算法" class="headerlink" title="二、PID控制算法"></a>二、PID控制算法</h1><p>PID控制算法其实是三种控制合起来的，PID(proportion integration differentiation)其实就是指比例，积分，微分控制，是一种非常经典的闭环控制算法。既然是闭环控制，图其实还是和上面类似的：</p><p><img src="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jobml1bmFu,size_16,color_FFFFFF,t_70-6007751.png" alt="img"></p><p>其中r(t)为被控对象状态的期望值，y(t)为被控对象状态的实际值，e(t)为被控对象期望值与实际值之间的偏差。</p><p>偏差输入给P、I、D三个控制器。Kp，Ki，Kd分别为比例、积分和微分参数，它们是PID控制的基本参数。</p><p>经过P、I、D三个控制器输出的值加和生成u(t)，u(t)为对被控对象的控制量。u(t)作用在被控对象上导致被控对象的状态y(t)改变。</p><p>有一点非常重要，就上述的<span style="background:#d4e9d5;">PID三种控制都是针对于误差Error的</span>。</p><h3 id="1-比例-P-控制"><a href="#1-比例-P-控制" class="headerlink" title="1. 比例(P)控制"></a>1. 比例(P)控制</h3><p>P控制的作用最明显，属于是在宏观上调控的。</p><p>P比例控制实现功能大概如下：</p><ul><li>当飞机快到达50m时，让它<font color="green">慢慢的上升</font></li><li>如果由于某些原因，温度降了不少，就让它<font color="green">稍微再快点上升</font></li><li>如果是离目标差很远(比如刚从地上开始飞)，就让它<font color="green">使劲往上飞</font></li></ul><p>是不是比上面提到的启停式好多了hhh</p><p>我们让Kp与误差Error建立了一次函数的关系，这样就可以通过改变Kp来改变我们调节的力度：Kp越大，调节作用就越激进；Kp越小，调节作用越保守</p><p>但是只有比例控制就可以了吗？</p><p>比例控制的缺点是无法消除<span style="background:#eef0f4;">稳态误差</span>，这时候就要谈到实际情况：飞机在飞行的时候，是会受各种阻力的，而由Kp调节的飞机会随着离50m越来越近而飞的越来越慢(甚至逐渐趋向于0)，这时候就会存在一种情况，就是当Kp小到上升的力正好和阻力相等的时候，我们会惊奇的发现：飞机停着不动了！！这时候它还没有达到我们的预期高度50m，这种当系统处于稳定时刻依然存在的误差即为稳态误差。</p><h3 id="2-积分-I-控制"><a href="#2-积分-I-控制" class="headerlink" title="2. 积分(I)控制"></a>2. 积分(I)控制</h3><p>如上所述，为了消除稳态误差，我们引入了积分控制，形成PI控制</p><p>u = kp * error +  ki * ∫ error</p><p>由上式可得，积分控制是通过对系统的误差来进行积分，然后把积分结果加到比例控制上。假如单用比例控制我们的飞机停在了45m处，这时候如果有积分控制，它会随着时间来增加从而使得飞机继续上升，这样就解决了稳态误差的问题</p><p>到了目标高度后，假设高度没有波动，积分值就不会再变动，飞机最终达到目标值。</p><p>积分时乘的系数Ki值越大，积分效果就越明显，但是一般我们不会设置太大的Ki，不然可能会导致在刚开始起飞时，就把积分量弄得很大，导致后续难以控制</p><p>在有了PI控制后，虽然解决了稳态误差问题，但是我们发现这个系统不是很稳，飞机在50m上下抖来抖去的。</p><p>因为当比较接近目标时，P的控制作用就比较小了。越接近目标，P的作用越小。有很多内在的或者外部的因素，使控制量发生小范围的摆动。D的作用就是让物理量的速度趋于0。</p><p>想想这种场景：我们向下拉一下一个处于稳定点的弹簧，然后松开，它是不是要好久才会停下来</p><h3 id="3-微分-D-控制"><a href="#3-微分-D-控制" class="headerlink" title="3. 微分(D)控制"></a>3. 微分(D)控制</h3><p>如果说比例和积分控制是事后调节，而微分作用则是事前预防控制，即一发现y(t)有变大或变小的趋势，马上就输出一个<span style="background:#dad5e9;">阻止其变化的控制信号</span>，以防止出现过冲或超调等。</p><p>如上弹簧的例子，我们要是给弹簧放在水里，弹簧是不是就会很快的停下来，就是因为水总是会给弹簧一个和其运动方向相反的力</p><p>还是以飞机举例，在飞机开始逐渐升高时，此时de(t)/dt为负值，相当于在原有的PI控制上加了一个负值，使得总控制量提前减小，避免飞机超过50m</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>PID控制的作用可以由下图来体现：</p><p><img src="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/middle_img_v2_57272ccd-aa2d-45d8-b7d9-34ceb824beel-6061836.gif" alt="middle_img_v2_57272ccd-aa2d-45d8-b7d9-34ceb824beel"></p><p>在单独调节Kp时，我们发现输出开始向期望值靠近，并且离得越近，逼近速度越慢，但此时我们发现逼近到最后，输出也无法完全达到期望值</p><p>此时通过调节Ki来消除静态误差，输出值开始向期望值逼近，但是又出现了明显的震荡现象</p><p>最后通过Kd来消除震荡</p><p>综上所述，给出PID控制的输出：</p><p><img src="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20221017224416868-6017861.png" alt="image-20221017224416868"></p><p>我们一般使用的是其离散形式，如下式所示：</p><p><img src="/2022/10/17/PID%E6%8E%A7%E5%88%B6%E5%8F%8A%E5%85%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20221017230157099-6018919.png" alt="image-20221017230157099"></p><p><strong>⭐️  <span style="background:#fbd4d0;">以上算出来的结果都是△量</span></strong></p><h1 id="三、-Java代码实现"><a href="#三、-Java代码实现" class="headerlink" title="三、 Java代码实现"></a>三、 Java代码实现</h1><h3 id="1-数据类型定义"><a href="#1-数据类型定义" class="headerlink" title="1. 数据类型定义"></a>1. 数据类型定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PidParam</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> kp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> ki;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> kd;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PidParam</span><span class="hljs-params">(<span class="hljs-type">double</span> kp,<span class="hljs-type">double</span> ki,<span class="hljs-type">double</span> kd,<span class="hljs-type">double</span> target)</span>&#123;<br>        <span class="hljs-built_in">this</span>.kp = kp;<br>        <span class="hljs-built_in">this</span>.ki = ki;<br>        <span class="hljs-built_in">this</span>.kd = kd;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-PID实现"><a href="#2-PID实现" class="headerlink" title="2. PID实现"></a>2. PID实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PidImpl</span> &#123;<br><br>    <span class="hljs-keyword">private</span> PidParam pidParam;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> sumError;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> lastError;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PidImpl</span><span class="hljs-params">(PidParam pidParam)</span>&#123;<br>        <span class="hljs-built_in">this</span>.pidParam = pidParam;<br>        <span class="hljs-built_in">this</span>.sumError = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.lastError = <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-comment">//main方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        calculate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PidParam</span>(<span class="hljs-number">0.3</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">50</span>),<span class="hljs-number">0</span>);<br>    &#125;<br><br>  <span class="hljs-comment">//给定目标值与初始值，开始执行PID算法直至达到稳态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(PidParam pidParam,<span class="hljs-type">double</span> curValue)</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> pidParam.getTarget();<br>        <span class="hljs-type">PidImpl</span> <span class="hljs-variable">pidImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PidImpl</span>(pidParam);<br>        <span class="hljs-comment">//循环直至达到稳态</span><br>        <span class="hljs-keyword">while</span>((target - curValue) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">variable</span> <span class="hljs-operator">=</span> pidImpl.PidAlgorithm(curValue);<br>            curValue += variable;<br>            System.out.println(curValue);<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">//单次PID执行流程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">PidAlgorithm</span><span class="hljs-params">(<span class="hljs-type">double</span> curValue)</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> pidParam.getTarget() - curValue;<br>        sumError += error;<br>        <span class="hljs-comment">//P控制</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">P_output</span> <span class="hljs-operator">=</span> pidParam.getKp() * error;<br>        <span class="hljs-comment">//I控制</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">I_output</span> <span class="hljs-operator">=</span> pidParam.getKi() * sumError;<br>        <span class="hljs-comment">//D控制</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">D_output</span> <span class="hljs-operator">=</span> pidParam.getKd() * (error - lastError);<br>        <span class="hljs-comment">//输出结果</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">variable</span> <span class="hljs-operator">=</span> P_output + I_output + D_output;<br>        lastError = error;<br>        <span class="hljs-keyword">return</span> variable;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法详解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习文档</title>
    <link href="/2022/10/04/Spring%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <url>/2022/10/04/Spring%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h1><p>地表最强Java框架，官网地址 <a href="https://spring.io/">https://spring.io/</a></p><h3 id="Spring-Framework的五大功能模块"><a href="#Spring-Framework的五大功能模块" class="headerlink" title="Spring Framework的五大功能模块"></a>Spring Framework的五大功能模块</h3><table><thead><tr><th>功能模块</th><th>功能介绍</th></tr></thead><tbody><tr><td><span style="background:#dad5e9;">Core Container</span></td><td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器</td></tr><tr><td><span style="background:#fbd4d0;">AOP&amp;Aspects</span></td><td>面向切面编程</td></tr><tr><td>Testing</td><td>提供了对 junit 或 TestNG 测试框架的整合</td></tr><tr><td>Data Access/Integration</td><td>提供了对数据访问/集成的功能</td></tr><tr><td>Spring MVC</td><td>提供了面向Web应用程序的集成功能</td></tr></tbody></table><h1 id="二、IOC"><a href="#二、IOC" class="headerlink" title="二、IOC"></a>二、IOC</h1><h4 id="1-什么是IOC"><a href="#1-什么是IOC" class="headerlink" title="1. 什么是IOC"></a>1. 什么是IOC</h4><p>IOC：Inversion of Control，翻译过来是反转控制。</p>]]></content>
    
    
    <categories>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis学习文档</title>
    <link href="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <url>/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、获取参数的情况"><a href="#一、获取参数的情况" class="headerlink" title="一、获取参数的情况"></a>一、获取参数的情况</h1><h3 id="获取参数的两种方式"><a href="#获取参数的两种方式" class="headerlink" title="获取参数的两种方式"></a>获取参数的两种方式</h3><p>MyBatis获取参数值的两种方式：${}和#{}</p><p><font color="red">${}的本质就是字符串拼接，#{}的本质就是占位符赋值</font></p><p>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时， 可以自动添加单引号</p><h4 id="1-单个字面量类型的参数"><a href="#1-单个字面量类型的参数" class="headerlink" title="1. 单个字面量类型的参数"></a>1. 单个字面量类型的参数</h4><p>可以使用${}和#{}以<font color="red">任意的名称</font>获取参数的值，注意${}需要手动加单引号</p><h4 id="2-多个字面量类型的参数"><a href="#2-多个字面量类型的参数" class="headerlink" title="2. 多个字面量类型的参数"></a>2. 多个字面量类型的参数</h4><p>默认放map中，以arg1，arg2…命名，也可以自己在接口的参数前面加注解@Param(“xxx”)，也可以直接传一个自定义map</p><h4 id="3-实体类类型的参数"><a href="#3-实体类类型的参数" class="headerlink" title="3. 实体类类型的参数"></a>3. 实体类类型的参数</h4><p>直接传映射对象，此时的参数名为get，set方法的属性</p><h1 id="二、各种查询功能"><a href="#二、各种查询功能" class="headerlink" title="二、各种查询功能"></a>二、各种查询功能</h1><h4 id="1-查询一个实体类对象"><a href="#1-查询一个实体类对象" class="headerlink" title="1. 查询一个实体类对象"></a>1. 查询一个实体类对象</h4><p>返回单个对象(例如User)，mapper接口返回值设置成对应的实体类即可</p><h4 id="2-查询一个list集合"><a href="#2-查询一个list集合" class="headerlink" title="2. 查询一个list集合"></a>2. 查询一个list集合</h4><p>返回多个对象，mapper接口返回值直接设置为list即可，当查询结果为多个但是返回结果类型设置成了单个，报错TooManyResultsException</p><h4 id="3-查询单个数据"><a href="#3-查询单个数据" class="headerlink" title="3. 查询单个数据"></a>3. 查询单个数据</h4><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221003231832045-4810323.png" alt="image-20221003231832045"></p><h4 id="4-查询单条记录（多个字段）"><a href="#4-查询单条记录（多个字段）" class="headerlink" title="4. 查询单条记录（多个字段）"></a>4. 查询单条记录（多个字段）</h4><p>当此时没有对应的实体类时，我们使用一个map来进行结果的存储</p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004115739590-4855863.png" alt="image-20221004115739590"></p><h4 id="5-查询多条记录（没有对应的实体类）"><a href="#5-查询多条记录（没有对应的实体类）" class="headerlink" title="5. 查询多条记录（没有对应的实体类）"></a>5. 查询多条记录（没有对应的实体类）</h4><p><font color="red">方式一：将4中的Map放到一个List中，形成多条记录</font></p><p>方式二：Map套Map，同时要指定一下键<img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004115941762.png" alt="image-20221004115941762"></p><h1 id="三、特殊SQL的执行"><a href="#三、特殊SQL的执行" class="headerlink" title="三、特殊SQL的执行"></a>三、特殊SQL的执行</h1><h4 id="1-模糊查询"><a href="#1-模糊查询" class="headerlink" title="1. 模糊查询"></a>1. 模糊查询</h4><p><span style="background:#fbd4d0;">like后的格式很重要，可能#取值会被当为字符串而不是占位符</span></p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004120119297.png" alt="image-20221004120119297"></p><h4 id="2-批量删除"><a href="#2-批量删除" class="headerlink" title="2. 批量删除"></a>2. 批量删除</h4><p>可以不使用where和or来实现，注意<span style="background:#f9eda6;">in的用法</span></p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004123908752-4858351.png" alt="image-20221004123908752"></p><h4 id="3-动态设置表名"><a href="#3-动态设置表名" class="headerlink" title="3. 动态设置表名"></a>3. 动态设置表名</h4><p>只能用${},不然表名会带引号导致查询出错</p><h4 id="4-添加功能获取自增的主键"><a href="#4-添加功能获取自增的主键" class="headerlink" title="4. 添加功能获取自增的主键"></a>4. 添加功能获取自增的主键</h4><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004125033453.png" alt="image-20221004125033453"></p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004125049062-4859050.png" alt="image-20221004125049062"></p><h1 id="四、自定义映射resultMap"><a href="#四、自定义映射resultMap" class="headerlink" title="四、自定义映射resultMap"></a>四、自定义映射resultMap</h1><h4 id="1-字段名和属性名不一致的情况"><a href="#1-字段名和属性名不一致的情况" class="headerlink" title="1. 字段名和属性名不一致的情况"></a>1. 字段名和属性名不一致的情况</h4><p>方法一：全局配置</p><p>直接在xml配置文件中进行配置，将<span style="background:#fbd4d0;">数据库的下划线命名法和java的驼峰命名法</span>进行转换</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="方法二：使用resultMap设置自定义映射"><a href="#方法二：使用resultMap设置自定义映射" class="headerlink" title="方法二：使用resultMap设置自定义映射"></a>方法二：使用resultMap设置自定义映射</h6><p>id：设置主键的映射关系<br>result：设置普通字段的映射关系</p><p><span style="background:#fbd4d0;">property：设置映射关系中实体类中的属性名 （实体类中的属性名）</span></p><p><span style="background:#fbd4d0;">column：设置映射关系中表中的字段名（sql中的字段名）</span></p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004134836469-4862520.png" alt="image-20221004134836469"></p><h4 id="2-多对一映射处理"><a href="#2-多对一映射处理" class="headerlink" title="2. 多对一映射处理"></a>2. 多对一映射处理</h4><p>查询员工信息以及员工所对应的部门信息，<span style="background:#d4e9d5;">即在查到的emp实体类中还有一个dept实体类，怎么样能让查出来的部门属性映射到dept中呢？</span></p><h6 id="方式一：级联"><a href="#方式一：级联" class="headerlink" title="方式一：级联"></a>方式一：级联</h6><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004141027304-4863829.png" alt="image-20221004141027304"></p><h6 id="方式二：使用association"><a href="#方式二：使用association" class="headerlink" title="方式二：使用association"></a>方式二：使用association</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;empDeptMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Emp&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;eid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;ename&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;ename&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Dept&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;did&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;did&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dname&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="方式三：分步查询"><a href="#方式三：分步查询" class="headerlink" title="方式三：分步查询"></a>方式三：分步查询</h6><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004142621553-4864783.png" alt="image-20221004142621553"></p><p>分步查询的优点：可以实现延迟加载</p><p>但是必须在核心配置文件中设置全局配置信息：</p><p>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载 </p><p>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。</p><p>否则，每个属性会按需加载此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载， <span style="background:#eef0f4;">fetchType=”lazy(延迟加载)|eager(立即加载)”</span></p><h4 id="3-一对多映射处理"><a href="#3-一对多映射处理" class="headerlink" title="3. 一对多映射处理"></a>3. 一对多映射处理</h4><h6 id="方式一：Collection"><a href="#方式一：Collection" class="headerlink" title="方式一：Collection"></a>方式一：Collection</h6><p>根据部门id查询部门信息以及部门中的员工信息</p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004144424364.png" alt="image-20221004144424364"></p><h6 id="方式二：分步查询"><a href="#方式二：分步查询" class="headerlink" title="方式二：分步查询"></a>方式二：分步查询</h6><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004145722982-4866648.png" alt="image-20221004145722982"></p><h1 id="五、动态SQL"><a href="#五、动态SQL" class="headerlink" title="五、动态SQL"></a>五、动态SQL</h1><p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了<br>解决<span style="background:#fbd4d0;">拼接SQL语句字符串时的痛点问题</span></p><h4 id="1-if"><a href="#1-if" class="headerlink" title="1. if"></a>1. if</h4><p>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004151222576.png" alt="image-20221004151222576"></p><h4 id="2-where"><a href="#2-where" class="headerlink" title="2. where"></a>2. where</h4><p>where和if一般结合使用：</p><p>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</p><p>若where标签中的if条件满足，则where标签会自动添加where关键字，<span style="background:#d4e9d5;">同时将条件最前方多余的and去掉</span></p><p><span style="background:#dad5e9;">注意：where标签不能去掉条件最后多余的and，，所以在if中and最好写在前面</span></p><h4 id="3-trim"><a href="#3-trim" class="headerlink" title="3. trim"></a>3. trim</h4><p>trim用于去掉或添加标签中的内容</p><p>常用属性：</p><p>prefix/suffix：在trim标签中的内容的前面/后面添加某些内容</p><p>prefixOverrides/suffixOverrides：在trim标签中的内容的前面/后面去掉某些内容</p><h4 id="4-choose、when、otherwise"><a href="#4-choose、when、otherwise" class="headerlink" title="4. choose、when、otherwise"></a>4. choose、when、otherwise</h4><p>choose：if</p><p>when：else if</p><p>otherwise：else(最多只能设置一个)</p><h4 id="5-foreach（常用）"><a href="#5-foreach（常用）" class="headerlink" title="5. foreach（常用）"></a>5. foreach（常用）</h4><p>collection：设置要循环的数组或集合</p><p>item：用一个字符串表示数组或集合中的每一个数据</p><p>separator：设置每次循环的数据之间的分隔符</p><p>open：循环的所有内容以什么开始</p><p>close：循环的所有内容以什么结束</p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004152638403-4868401.png" alt="image-20221004152638403"></p><p>批量删除一</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>delete from t_emp where<br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span> <br>eid = #&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>批量删除二</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteMoreByArray&quot;</span>&gt;</span><br>delete from t_emp where eid in<br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;eids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;eid&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>#&#123;eid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="6-SQL片段（常用）"><a href="#6-SQL片段（常用）" class="headerlink" title="6. SQL片段（常用）"></a>6. SQL片段（常用）</h4><p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p><p>设置sql片段</p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004154933863-4869777.png" alt="image-20221004154933863"></p><p>引用sql片段</p><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004154850955-4869732.png" alt="image-20221004154850955"></p><h1 id="六、MyBatis的缓存"><a href="#六、MyBatis的缓存" class="headerlink" title="六、MyBatis的缓存"></a>六、MyBatis的缓存</h1><h4 id="1-MyBatis的一级缓存"><a href="#1-MyBatis的一级缓存" class="headerlink" title="1. MyBatis的一级缓存"></a>1. MyBatis的一级缓存</h4><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就 会从缓存中直接获取，不会从数据库重新访问</p><p>使一级缓存失效的四种情况：</p><p>1）不同的SqlSession对应不同的一级缓存</p><p>2）同一个SqlSession但是查询条件不同</p><p>3）同一个SqlSession两次查询期间执行了任何一次增删改操作</p><p>4）同一个SqlSession两次查询期间手动清空了缓存</p><h4 id="2-MyBatis的二级缓存"><a href="#2-MyBatis的二级缓存" class="headerlink" title="2. MyBatis的二级缓存"></a>2. MyBatis的二级缓存</h4><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被 缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p><span style="background:#fbd4d0;">二级缓存开启的条件：</span></p><p>a&gt;在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置 </p><p>b&gt;在映射文件中设置标签<cache></cache></p><p>c&gt;二级缓存必须在SqlSession关闭或提交之后有效</p><p>d&gt;查询的数据所转换的实体类类型必须实现序列化的接口</p><p><span style="background:#dad5e9;">二级缓存失效的情况：</span></p><p>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p><h4 id="二级缓存相关配置"><a href="#二级缓存相关配置" class="headerlink" title=". 二级缓存相关配置"></a>. 二级缓存相关配置</h4><p>在mapper配置文件中添加的cache标签可以设置一些属性： </p><p>①eviction属性：缓存回收策略，默认的是 LRU。</p><p>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</p><p>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 </p><p>②flushInterval属性：刷新间隔，单位毫秒</p><p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 </p><p>③size属性：引用数目，正整数</p><p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出 </p><p>④readOnly属性：只读， true/false</p><p>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了  很重要的性能优势。</p><p>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是<br>false。</p><h4 id="4-MyBatis缓存查询的顺序"><a href="#4-MyBatis缓存查询的顺序" class="headerlink" title="4. MyBatis缓存查询的顺序"></a>4. MyBatis缓存查询的顺序</h4><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</p><p>如果二级缓存没有命中，再查询一级缓存</p><p>如果一级缓存也没有命中，则查询数据库</p><p><span style="background:#dad5e9;">为什么一级缓存有二级缓存没有的数据？因为一级缓存只有在关闭或者提交的时候才会把数据存到二级缓存中</span></p><p>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</p><h1 id="七、MyBatis逆向工程"><a href="#七、MyBatis逆向工程" class="headerlink" title="七、MyBatis逆向工程"></a>七、MyBatis逆向工程</h1><p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。 Hibernate是支持正向工<br>程的。</p><p><span style="background:#d4e9d5;">逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</span></p><p>Java实体类 </p><p>Mapper接口 </p><p>Mapper映射文件</p><h4 id="1-添加依赖和插件"><a href="#1-添加依赖和插件" class="headerlink" title="1. 添加依赖和插件"></a>1. 添加依赖和插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 构建过程中用到的插件    --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的    --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 插件的依赖    --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>               <span class="hljs-comment">&lt;!-- 逆向工程的核心依赖    --&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>               <span class="hljs-comment">&lt;!-- MySQL驱动    --&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-创建逆向工程的配置文件（先创建MyBatis核心配置文件）"><a href="#2-创建逆向工程的配置文件（先创建MyBatis核心配置文件）" class="headerlink" title="2. 创建逆向工程的配置文件（先创建MyBatis核心配置文件）"></a>2. 创建逆向工程的配置文件（先创建MyBatis核心配置文件）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">       <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span> </span><br><span class="hljs-meta">       <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">           targetRuntime: 执行生成的逆向工程的版本</span><br><span class="hljs-comment">                   MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="hljs-comment">                   MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><br><span class="hljs-comment">    --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 数据库的连接信息    --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                       <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis? </span></span><br><span class="hljs-string"><span class="hljs-tag">serverTimezone=UTC&quot;</span></span><br><span class="hljs-tag">                       <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                       <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span> <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.pojo&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略    --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- Mapper接口的生成策略    --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span>  <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 逆向分析的表    --&gt;</span><br>       <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>       <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名    --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-执行MBG插件的generate目标"><a href="#3-执行MBG插件的generate目标" class="headerlink" title="3. 执行MBG插件的generate目标"></a>3. 执行MBG插件的generate目标</h4><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004172005204-4875207.png" alt="image-20221004172005204"></p><h4 id="4-最终效果"><a href="#4-最终效果" class="headerlink" title="4. 最终效果"></a>4. 最终效果</h4><p><img src="/2022/10/03/MyBatis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/image-20221004172034809-4875237.png" alt="image-20221004172034809"></p><h1 id="八、分页插件"><a href="#八、分页插件" class="headerlink" title="八、分页插件"></a>八、分页插件</h1><h4 id="1-插件引入"><a href="#1-插件引入" class="headerlink" title="1. 插件引入"></a>1. 插件引入</h4><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在NyBatis的核心配置文件中配置分页插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--设置分页插件--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-插件使用"><a href="#2-插件使用" class="headerlink" title="2. 插件使用"></a>2. 插件使用</h4><p>1）在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能</p><p>==pageNum==：当前页的页码</p><p>==pageSize==：每页显示的条数</p><p>2）在查询获取list集合之后，使用PageInfo<T> pageInfo = new PageInfo&lt;&gt;(List<T> list, int<br>navigatePages)获取分页相关数据</T></T></p><p>list：分页之后的数据</p><p>navigatePages：导航分页的页码数</p><p>3）分页相关数据</p><p>PageInfo{</p><p>pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8, </p><p>list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, </p><p>pages=8, reasonable=false, pageSizeZero=false},</p><p>prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, </p><p>hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, </p><p>navigatepageNums=[4, 5, 6, 7, 8]</p><p>}</p><p>pageNum：当前页的页码 </p><p>pageSize：每页显示的条数 </p><p>==index = （pageNum - 1）* pageSize==</p><p>size：当前页显示的真实条数 </p><p>total：总记录数</p><p>pages：总页数 </p><p>prePage：上一页的页码 </p><p>nextPage：下一页的页码</p><p>isFirstPage/isLastPage：是否为第一页/最后一页 </p><p>hasPreviousPage/hasNextPage：是否存在上一页/下一页 </p><p>navigatePages：导航分页的页码数</p><p>navigatepageNums：导航分页的页码，[1,2,3,4,5]</p><p><a>首页</a> <a>上一页 </a> 2 3 4 5 6 <a>下一页</a> <a>末页</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo搭建github博客</title>
    <link href="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-前置准备"><a href="#一、-前置准备" class="headerlink" title="一、 前置准备"></a>一、 前置准备</h2><p>​    系统：macOS</p><p>​    前置环境：node、npm、git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">node node -version<br>npm -v<br>git -version<br></code></pre></td></tr></table></figure><h2 id="二、创建GitHub仓库"><a href="#二、创建GitHub仓库" class="headerlink" title="二、创建GitHub仓库"></a>二、创建GitHub仓库</h2><p>在GitHub上创建一个仓库用来保存我们博客的网页以及各种资源</p><h4 id="1-点击进入仓库创建页面"><a href="#1-点击进入仓库创建页面" class="headerlink" title="1. 点击进入仓库创建页面"></a>1. 点击进入仓库创建页面</h4><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930185308283.png"></p><h4 id="2-填写仓库名，必须是-用户名-github-io-我这里报错是因为已经创建过"><a href="#2-填写仓库名，必须是-用户名-github-io-我这里报错是因为已经创建过" class="headerlink" title="2. 填写仓库名，必须是[用户名].github.io,我这里报错是因为已经创建过"></a>2. 填写仓库名，必须是[用户名].github.io,我这里报错是因为已经创建过</h4><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930191911864-4536772.png" alt="image-20220930191911864"></p><h4 id="3-创建一个index-html来进行主页测试"><a href="#3-创建一个index-html来进行主页测试" class="headerlink" title="3. 创建一个index.html来进行主页测试"></a>3. 创建一个index.html来进行主页测试</h4><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930194148611-4538111.png" alt="image-20220930194148611"></p><h4 id="4-新文件的名字必须为index-html，内容先随便写下，填写之后点击Commit-new-file提交"><a href="#4-新文件的名字必须为index-html，内容先随便写下，填写之后点击Commit-new-file提交" class="headerlink" title="4. 新文件的名字必须为index.html，内容先随便写下，填写之后点击Commit new file提交"></a>4. 新文件的名字必须为<code>index.html</code>，内容先随便写下，填写之后点击<code>Commit new file</code>提交</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>yaorongke<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Rivers-boy的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930194542046-4538346.png" alt="image-20220930194542046"></p><h4 id="5-登陆网页查看效果"><a href="#5-登陆网页查看效果" class="headerlink" title="5. 登陆网页查看效果"></a>5. 登陆网页查看效果</h4><h1 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h1><p>我们使用Hexo来创建我们的博客，Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章。</p><h4 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1. 安装Hexo"></a>1. 安装Hexo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h4 id="2-添加环境变量并查看版本"><a href="#2-添加环境变量并查看版本" class="headerlink" title="2. 添加环境变量并查看版本"></a>2. 添加环境变量并查看版本</h4><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量中后，即可直接使用 hexo <command></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile<br>hexo -v<br></code></pre></td></tr></table></figure><h4 id="3-创建一个项目并初始化"><a href="#3-创建一个项目并初始化" class="headerlink" title="3. 创建一个项目并初始化"></a>3. 创建一个项目并初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><h4 id="4-本地启动"><a href="#4-本地启动" class="headerlink" title="4. 本地启动"></a>4. 本地启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><h4 id="5-网页访问"><a href="#5-网页访问" class="headerlink" title="5. 网页访问"></a>5. 网页访问</h4><p>从浏览器上访问 <a href="http://localhost:4000，其初始效果如下所示">http://localhost:4000，其初始效果如下所示</a></p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930200716427-4539638.png" alt="image-20220930200716427"></p><h1 id="四、安装Fluid主题"><a href="#四、安装Fluid主题" class="headerlink" title="四、安装Fluid主题"></a>四、安装Fluid主题</h1><p>也可以选择next，个人比较喜欢fluid主题的这个风格，安装步骤参考官网 <a href="https://gitcode.net/mirrors/fluid-dev/hexo-theme-fluid?utm_source=csdn_github_accelerator">Fluid官网</a></p><h4 id="1-获取主题最新版本"><a href="#1-获取主题最新版本" class="headerlink" title="1. 获取主题最新版本"></a>1. 获取主题最新版本</h4><p>这里官网给出两种方式，npm+根目录下配置文件   &amp;&amp;   下载安装包解压，本人使用的是第一种</p><p>进入博客目录后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>之后在博客目录下创建主题配置文件  <code>_config.fluid.yml </code>，并将<code>_config.yml</code>的内容复制过去</p><h4 id="2-指定主题"><a href="#2-指定主题" class="headerlink" title="2. 指定主题"></a>2. 指定主题</h4><p>修改<code>_config.yml</code>中的配置，增加：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h4 id="3-创建各个页面"><a href="#3-创建各个页面" class="headerlink" title="3. 创建各个页面"></a>3. 创建各个页面</h4><p>包括<code>关于</code>，<code>分类</code>，<code>标签</code>等等</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性</p><p>修改之后的属性应该是这样的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: about<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">09</span>-<span class="hljs-number">30</span> <span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">22</span><br><span class="hljs-attribute">layout</span>: about<br></code></pre></td></tr></table></figure><h4 id="4-本地启动-1"><a href="#4-本地启动-1" class="headerlink" title="4. 本地启动"></a>4. 本地启动</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>再次访问 <a href="http://localhost:4000，`Fluid`主题风格的页面如下">http://localhost:4000，`Fluid`主题风格的页面如下</a></p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930203020380-4541022.png" alt="image-20220930203020380"></p><h1 id="五、个性化页面展示"><a href="#五、个性化页面展示" class="headerlink" title="五、个性化页面展示"></a>五、个性化页面展示</h1><p>这些都在配置文件里，详细参考  <a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">官方文档</a></p><h4 id="1-概念理解"><a href="#1-概念理解" class="headerlink" title="1. 概念理解"></a>1. 概念理解</h4><p>首先我们要清楚hexo下有两个配置文件<code>_config.yml</code>，<code>_config.fluid.yml</code>（如果是解压方法安装的，这个配置文件为<code>theme/fluid/_config.yml</code>）</p><p>其中<code>_config.yml</code>是整个博客的配置即站点配置</p><p>而<code>_config.fluid.yml</code>是仅仅是fluid这个主题的配置</p><h4 id="2-博客标题配置-页面左上角"><a href="#2-博客标题配置-页面左上角" class="headerlink" title="2. 博客标题配置(页面左上角)"></a>2. 博客标题配置(页面左上角)</h4><p><code>_config.yml</code>中的配置如下：</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930204341279-4541824.png" alt="image-20220930204341279"></p><p><code>_config.fluid.yml</code>中的配置如下：</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930204534721-4541936.png" alt="image-20220930204534721"></p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930204707117-4542029.png" alt="image-20220930204707117"></p><p>可以看出，对于博客标题，主题配置会覆盖站点配置</p><h4 id="3-博客首页设置"><a href="#3-博客首页设置" class="headerlink" title="3. 博客首页设置"></a>3. 博客首页设置</h4><p>在<code>_config.fluid.yml</code>中：</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20220930204920564-4542162.png" alt="image-20220930204920564"></p><h1 id="六、阅读量统计-amp-评论功能"><a href="#六、阅读量统计-amp-评论功能" class="headerlink" title="六、阅读量统计&amp;评论功能"></a>六、阅读量统计&amp;评论功能</h1><p><code>Fluid</code>主题已经内置了统计阅读量的代码，但是需要借助第三方来进行统计，这里我们选择免费的LeanCloud来进行统计</p><h4 id="1-注册LeanCloud"><a href="#1-注册LeanCloud" class="headerlink" title="1. 注册LeanCloud"></a>1. 注册LeanCloud</h4><p>进入<a href="https://console.leancloud.cn/register">LeanCloud官网</a>进行注册</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003123331885-4771614.png" alt="image-20221003123331885"></p><h4 id="2-之后进行实名认证与邮箱验证"><a href="#2-之后进行实名认证与邮箱验证" class="headerlink" title="2. 之后进行实名认证与邮箱验证"></a>2. 之后进行实名认证与邮箱验证</h4><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70.png" alt="请添加图片描述"></p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003133656995-4775419.png" alt="image-20221003133656995"></p><h4 id="3-创建应用并记录AppID与AppKey"><a href="#3-创建应用并记录AppID与AppKey" class="headerlink" title="3. 创建应用并记录AppID与AppKey"></a>3. 创建应用并记录AppID与AppKey</h4><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-20221003133815987.png" alt="请添加图片描述"></p><p>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <font color="red"><code>AppID</code></font> 和<font color="red"><code>AppKey</code></font>，记录下来后面配置要用</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-20221003133834510.png" alt="请添加图片描述"></p><h4 id="4-在fluid里进行配置"><a href="#4-在fluid里进行配置" class="headerlink" title="4. 在fluid里进行配置"></a>4. 在fluid里进行配置</h4><p>首先修改文章阅读量统计</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003145730406.png" alt="image-20221003145730406"></p><p>引入LeanCloud：将之前的 <font color="red"><code>AppID</code></font> 和<font color="red"><code>AppKey</code></font>填入</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003145849719-4780332.png" alt="image-20221003145849719"></p><p>开计数功能</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003150009923-4780414.png" alt="image-20221003150009923"></p><p>展示其他统计数</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003150112832-4780474.png" alt="image-20221003150112832"></p><h4 id="5-添加评论功能"><a href="#5-添加评论功能" class="headerlink" title="5. 添加评论功能"></a>5. 添加评论功能</h4><p>首先开启评论插件valine</p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003150303042.png" alt="image-20221003150303042"></p><p>再次配置LeanCloud：填入之前的 <font color="red"><code>AppID</code></font> 和<font color="red"><code>AppKey</code></font></p><p><img src="/2022/09/30/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/image-20221003150359475-4780642.png" alt="image-20221003150359475"></p><h1 id="七、发布到Gitub-Pages上"><a href="#七、发布到Gitub-Pages上" class="headerlink" title="七、发布到Gitub Pages上"></a>七、发布到Gitub Pages上</h1><p>hexo g -d</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
